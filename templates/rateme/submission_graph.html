{% extends 'objctify/base.html' %}
{% load staticfiles %}


{% block head_block %}
    <script type="text/javascript" src="{% static 'js/jquery-1.11.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'js/bootstrap.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'js/echarts.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'js/math.min.js' %}"></script>
    <script src="{% static 'js/three.min.js' %}"></script>
    <script src="{% static 'averagefaces/js/controls/OrbitControls.js' %}"></script>
    <script src="{% static 'js/msgpack.min.js' %}"></script>
    <script id="vertex_shh" type="x-shader/x-vertex">
            #include <morphtarget_pars_vertex>

			varying vec2 vUv;

			void main()
			{
			    #include <begin_vertex>
			    #include <morphtarget_vertex>

				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}


    </script>
    <script id="fragment_shh" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform sampler2D faces[5];
			uniform float alphas[5];

			varying vec2 vUv;

			void main(void)
			{
				vec3 c;
				for(int i = 0; i < 5; i++) {
					vec4 C = texture2D(faces[i], vUv);
					c += C.rgb * alphas[i];
				}
			    gl_FragColor= vec4(c, 1.0);
			}


    </script>
    <script>
        var camera, controls, scene, renderer;
        var face, mixer;
        var vertShader = document.getElementById('vertex_shh').innerHTML;
        var fragShader = document.getElementById('fragment_shh').innerHTML;

        var FACENAMES = [
            "{% static 'averagefaces/averageFaces_F_4_50' %}",
        ];
        {#            var FACENAMES = [#}
        {#                    "{% static 'averagefaces/averageFaces_M_0_50' %}",#}
        {#                    "{% static 'averagefaces/averageFaces_M_1_50' %}",#}
        {#                    "{% static 'averagefaces/averageFaces_M_2_50' %}",#}
        {#                    "{% static 'averagefaces/averageFaces_M_3_50' %}",#}
        {#                    "{% static 'averagefaces/averageFaces_M_4_50' %}",#}
        {#			];#}
        var geometrys = [];
        var currMesh;
        var face_features = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];

        var textureArray = [];
        for (var i in FACENAMES) {
            var FACENAME = FACENAMES[i];
            textureArray.push(THREE.ImageUtils.loadTexture(FACENAME + ".jpg"))
        }

        var uniforms = {    // custom uniforms (your textures)
            faces: {type: "tv", value: textureArray},
            alphas: {type: "fv1", value: [1, 0, 0, 0, 0]}
        };

        var material_shh = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertShader,
            fragmentShader: fragShader,
            morphTargets: true
        });

        function downloadMsgPack(url, callback) {
            var oReq = new XMLHttpRequest();
            oReq.open("GET", url, true);
            oReq.responseType = "arraybuffer";

            oReq.onload = function (oEvent) {
                var arrayBuffer = oReq.response; // Note: not oReq.responseText
                if (arrayBuffer) {
                    var byteArray = new Uint8Array(arrayBuffer);
                    var data = msgpack.decode(byteArray);
                    callback(data);
                }
            };
            oReq.send();
        }

        function loadmesh(FACENAME, i) {
            var loader = new THREE.JSONLoader();
            return function (jsonobj) {
                var object = loader.parse(jsonobj);
                var geometry = object.geometry;

                console.log("" + i + " " + FACENAME);

                geometrys[FACENAME] = geometry;

                geometryLoaded();
            }
        }

        function modelReady(data) {
            model = data;
            console.log("model downloaded");

            var meshverts = meshFromFeatures(model, face_features).valueOf();
            createMesh(meshverts, model.faces, model.UVs);
        }

        function meshFromFeatures(model, features) {
            alpha = math.matrix(features);
            var shape = math.multiply(model.shapePC, alpha);
            shape = math.add(model.shapeMU, shape);
            var numVert = parseInt(shape._size[0] / 3);
            var verts = shape.reshape([numVert, 3]);

            return verts;
        }

        function createMesh(verts, faces, uvs) {
            scene.remove(currMesh);

            var geometry = new THREE.Geometry();
            geometry.dynamic = true;

            for (var i = 0; i < verts.length; i++) {
                var vert = verts[i];
                geometry.vertices.push(new THREE.Vector3(vert[0], vert[1], vert[2]));
            }
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                geometry.faces.push(new THREE.Face3(face[0], face[1], face[2]));

                // geometry.faceVertexUvs[0].push([    new THREE.Vector2(uvs[face[0]][0], 1-uvs[face[0]][1]),
                //                                     new THREE.Vector2(uvs[face[1]][0], 1-uvs[face[1]][1]),
                //                                     new THREE.Vector2(uvs[face[2]][0], 1-uvs[face[2]][1])]);
            }

            geometry.computeFaceNormals();

            // var material = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('img/isomap.jpg') } );
            var material = new THREE.MeshNormalMaterial();
            currMesh = new THREE.Mesh(geometry, material);
            scene.add(currMesh);
        }

        function arrayContainsArray(a1, a2) {
            for (ai in a2) {
                ae = a2[ai];
                if (!(ae in a1)) {
                    return false;
                }
            }
            return true;
        }

        function geometryLoaded() {
            //only run when all geometry is loaded
            if (arrayContainsArray(geometrys, FACENAMES)) {
                var faceGeometry = geometrys[FACENAMES[0]];

                var i = 0;
                for (var key in geometrys) {
                    faceGeometry.morphTargets[i] = {name: key, vertices: geometrys[key].vertices};
                    i++;
                }
                faceGeometry.computeMorphNormals();

                face = new THREE.Mesh(faceGeometry, material_shh);
                scene.add(face);

                mixer = new THREE.AnimationMixer(face);
                var clip = THREE.AnimationClip.CreateFromMorphTargetSequence('gallop', faceGeometry.morphTargets, 30);
                mixer.clipAction(clip).setDuration(5).play();
            }
        }

        function init() {
            var container = document.getElementById('3dcanvas');


            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(0x444444);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);


            container.appendChild(renderer.domElement);

            {#				camera = new THREE.PerspectiveCamera( 60, window.clientWidth / window.clientHeight, 1, 2000 );#}

            camera = new THREE.OrthographicCamera(container.clientWidth / -2, container.clientWidth / 2, container.clientHeight / 2, container.clientHeight / -2, 1, 1000);
            {#				camera = new THREE.PerspectiveCamera( 60, window.clientWidth / window.clientHeight, 1, 2000 );#}
            camera.position.z = 200;
            camera.position.x = 100;


            light = new THREE.AmbientLight(0xcccccc);
            scene.add(light);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target = new THREE.Vector3(0, 0, -50);
            controls.enableDamping = true;
            controls.dampingFactor = 1.25;
            controls.enableZoom = true;

            {#for (var i in FACENAMES) {#}
            {#    var FACENAME = FACENAMES[i];#}
            {#    downloadMsgPack(FACENAME + '_fitted.msg', loadmesh(FACENAME, i));#}
            {##}
            downloadMsgPack("{% static 'model/bfm_small.msg' %}", modelReady);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            var container = document.getElementById('3dcanvas');

            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true

            render();
        }

        var prevTime = Date.now();

        function render() {
            if (mixer) {
                var time = Date.now();
                mixer.update((time - prevTime) * 0.001);
                prevTime = time;

                uniforms.alphas.value = face.morphTargetInfluences;
            }
            renderer.render(scene, camera);
        }

        function onLoad() {
            init();
            animate();
        }

        $(function () {
            onLoad();
        });
    </script>
{% endblock %}

{% block content_block %}
    <div class="col-xs-8">
        <div id="chart" style="width:100%; height:100%;"></div>
    </div>
    <div class="col-xs-4">
        <div id="3dcanvas" style="width:500px; height:500px; background-color:#979797;"></div>
    </div>

    <script type="text/javascript">
        // based on prepared DOM, initialize echarts instance
        var myChart = echarts.init(document.getElementById('chart'));
        all_data = {
            "rateme-F": [],
            "rateme-M": []
        };


        function receive_data(data_key) {
            return function (data) {
                arr_data = convert_data(data.results, "created", "calculated_rating");
                all_data[data_key] = all_data[data_key].concat(arr_data);
                // fill in data
                myChart.setOption({
                    series: [{
                        // find series by name
                        name: data_key,
                        data: all_data[data_key]
                    }]
                });

                if (data.next) {
                    $.get(data.next).done(receive_data(data_key));
                }
            }
        }

        // Asynchronous data loading
        $.get('/api/submissions?format=json&gender=F').done(receive_data("rateme-F"));
        $.get('/api/submissions?format=json&gender=M').done(receive_data("rateme-M"));

        function convert_data(data, x_key, y_key) {
            out = [];
            for (i = 0; i < data.length; i++) {
                d = data[i];
                out.push([d[x_key], d[y_key], d]);
            }
            return out;
        }

        option = {
            backgroundColor: new echarts.graphic.RadialGradient(0.3, 0.3, 0.8, [{
                offset: 0,
                color: '#f7f8fa'
            }, {
                offset: 1,
                color: '#cdd0d5'
            }]),
            title: {
                text: 'RateMe'
            },
            tooltip: {
                formatter: function (params) {
                    let data = params.data[2];
                    face_features = data.images[0].face_processings[0].shape_coefficients;

                    var meshverts = meshFromFeatures(model, face_features).valueOf();
                    createMesh(meshverts, model.faces, model.UVs);

                    let rez = '';//<iframe src="/submission/' + data.id + '" style="width:100%; height:100%"></iframe>';
                    return rez;
                },
                alwaysShowContent: true,
                triggerOn: 'mousemove|click',
                enterable: true,
                extraCssText: "width:400px; height: 500px;"
            },
            dataZoom: [
                {
                    type: 'slider',
                    xAxisIndex: 0,
                    start: 0,
                    end: 100
                },
                {
                    type: 'inside',
                    xAxisIndex: 0,
                    start: 0,
                    end: 100
                },
                {
                    type: 'slider',
                    yAxisIndex: 0,
                    start: 0,
                    end: 100
                },
                {
                    type: 'inside',
                    yAxisIndex: 0,
                    start: 0,
                    end: 100
                }
            ],
            legend: {
                right: 10,
                data: ['rateme-M', 'rateme-F']
            },
            xAxis: {
                type: "time",
                splitLine: {
                    lineStyle: {
                        type: 'dashed'
                    }
                },
            },
            yAxis: {
                splitLine: {
                    lineStyle: {
                        type: 'dashed'
                    }
                },
                scale: true
            },
            series: [{
                name: 'rateme-M',
                data: [],
                type: 'scatter',
                symbolSize: function (data) {
                    return Math.sqrt(data[2].score);
                },
                itemStyle: {
                    normal: {
                        color: "#52a8fd"
                    }
                }
            },
                {
                    name: 'rateme-F',
                    data: [],
                    type: 'scatter',
                    symbolSize: function (data) {
                        return Math.sqrt(data[2].score);
                    },
                    itemStyle: {
                        normal: {
                            color: "#ffd432"
                        }
                    }
                }]
        };

        // use configuration item and data specified to show chart
        myChart.setOption(option);
    </script>
{% endblock %}